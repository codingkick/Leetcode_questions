class Solution {
public:
    int func(vector<int> &dp,int ind,vector<vector<int>> &job)
    {
        if(dp[ind] != -1)
            return dp[ind];
//         two options : either that job is taken or not taken.
//         what if not taken
        int v1 = func(dp,ind-1,job);
//         what if taken.
//         the max which i can generate by including current job is equal to max that can be generated by all the job which started earlier and not overlapping with current job.
        int i = 0,j = ind-1;
        int v2 = job[ind][2];
        int v = -1;
        while(i<=j)
        {
            int mid = (i + j)/2;
            if(job[mid][0] > job[ind][1])
            {
                j = mid - 1;
            }
            else
            {
                v = mid;
                i = mid + 1;
            }
        }
        if(v != -1)
            v2 += func(dp,v,job);
        dp[ind] = max(v1,v2);
        return dp[ind];
    }
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = profit.size();
        vector<int> dp(n,-1);
        vector<vector<int>> job;
        for(int i=0;i<n;i++)
            job.push_back({endTime[i],startTime[i],profit[i]});
        sort(job.begin(),job.end());
        dp[0] = job[0][2];
        return func(dp,n-1,job);
    }
};